import $ from '../core';

// Метод который позволит быстро менять html структуры внутри какого-то элемента
$.prototype.html = function(content) { // контент который мы будем помещать внутрь элемента
    for(let i = 0; i < this.length; i++) {
        if (content) {
            this[i].innerHTML = content;
        } else {
            return this[i].innerHTML; // ЭТО НЕ ОБЪЕКТ, мы не можем использовать на него методы объекта, мы получаем только контент
        }
    }

    return this;
};
/* 1) Когда мы передаем элемент с контентом и замещать то что было внутри
   2) Есди контент не был передан, то мы хотим получить содержимое внутри страницы
Что это значит на практике: если в main.js прописать console.log($('button').html()); то в консоль мы получим click me(название кнопки) 
а если пропишем console.log($('button').html('hello')); то КНОПКА ПОМЕНЯЕТ СВОЕ НАЗВАНИЕ НА hello */

// МЕНЯЕТ КЛАСС АКТИВНОСТИ ПРИ КЛИКЕ. Это будет фция которая принимает один аргумент i - номер элемента
$.prototype.eq = function(i) { 
    const swap = this[i]; // тот элемент который нам понадобиться
    const objLength = Object.keys(this).length; /* Считаем кство свойст у объекта, превращая объект в массив
 Object.keys(this) -  во внутрь передаем объект который нам нужно трасформировать в массив. Теперь мы знаем кство свойств у нашего объекта*/

    // Избавляемся от лишних элементов
    for(let i = 0; i < objLength; i++) { /* Здесь мы не можем взять this.length, потому что оно отображает кство элементов которые 
лежат внутри this, но оно не отображает реальное кство свойств которые могут быть у этого объекта, помимо length у нас могут быть свои
свойсвта к примеру в core.js. По-этому сначала нам нужно получить кство свойств в этом объекте */

        delete this[i];
    }

    this[0] = swap; // только один элемент
    this.length = 1; // только одно свойство
    return this;
}; /* У нас будет объект this который содержил элементы, их мб много, с помощью ленг мы получим все. Нам нужно отфильровать объект так
что бы остался элемент который подходит по селектору который мы передаем, условно если нам нужен второй , то от остальных избавляемся 
и оставляем только второй */
/* Результат работы : $('button').on('click', function() {
    $('div').eq(2).toggleClass('active');  Благодаря тому что мы возрвращаем объект eq(2), все тот же с теме же свойствами и 
    элементами this[0] = swap; this.length = 1, то мы можем дальше использовать метод toggleClass
});  
    ТЕПЕРЬ ПРИ КЛИКЕ НА КНОПКУ КЛИК МЕНЯЕТСЯ КЛАСС АКТИВНОСТИ У 3го ДИВА*/


// Получение НОМЕР ЭЛЕМЕНТА ПО ПОРЯДКУ, которые имеют общего родителя (Например у нас есть три дива, у них родитель body)
$.prototype.index = function() { 
    const parent = this[0].parentNode; // получаем родителя. this[0] - потому этот метод будет использоваться на одном элементе
    const childs = [...parent.children]; /* получим всех потомков родителя. С помощью parent.children мы получим хтмл коллекцию, те
псевдо массив и метод findIndex который нам понадобиться в будущем на него не сработает. Поэтому нужно превратить эту коллекцю
в СТАНДАРТНЫЙ МАССИВ. При помощи спред опператора, мы разварачиваем нашу коллекцию, беря все элемента и разварачивая в виде обычного массива*/

    // Во внутрь findIndex нужно передать коллбек фцию которая должна по какому-то критерию найти нужный индекс
    const findMyIndex = (item) => {
        return item == this[0]; /* У нас в переменной childs лежит массив, в массиве есть определенное кство элементов, на каждом из
этих элементов будет запускаться findMyIndex. Эта фция принимает в себя каждый отдельный item, те каждый элемент внутри childs.
И это фильтрационая фция которая вернет нам тот элемент, который будет тем который нам нужен, те перебирая item мы найдем наш
this[0]. И когда findMyIndex вернет нам элемент то в findIndex мы уже получим номер этого элемента */
    };

    return childs.findIndex(findMyIndex); 
};
/* Этот метод тоже в конце НЕ БУДЕТ возвращать объект с которым можно будет взаимподействовать, а просто число.
Алгоритм: этот метод будет использовать только на одном элементе, ведь нам нужно получить индекс только одного элемента. Нам нужно
получить сначало родителя и так же его соседей которые подходят по селектору. И среди всей этой коллекции найти индекс того элемента
который нам нужен */
/* Результат работы : $('div').click(function () { // вешаем на дивы метод клика который мы создали ранее, передаем коллбек фцию
    console.log($(this).index()); // this тот элемент на котором был клик
}); 
    При клике на один из наших дивов мы получаем его номер по порядку */


// Теперь будем получать элемент по КЛАССУ
$.prototype.find = function(selector) {
    let numberOfItems = 0; // кство элементов который нам ПОДОШЛИ по селектору. ЭТО ОБЩЕЕ КСТВО
    let counter = 0; // будет отвечать за кство новых элементов который мы записали в this. ЭТО ЗА КСТВО ЗАПИСАННЫХ

    const copyObj = Object.assign({}, this); /* делаем копию объекта, что бы не было багов. В обычный объект записали this, теперь в 
переменной copyObj будет лежать НЕГЛУБОКАЯ КОПИЯ нашего объекта this*/

    for(let i = 0; i < copyObj.length; i++) {
/* Теперь с помощью querySelectorAll мы попроубем найти нужные нам элементы по селекторы проверив каждый элемент в copyObj */
        const arr = copyObj[i].querySelectorAll(selector); // тоже самое что мы использовали this[i] в прошлом коде

        //Может быть так что не будет ниодного подходящего нам элемента по селектору
        if(arr.length == 0) {
            continue; // просто пропускам эту итерацию цикла что бы не было ошибки
        } 

        for(let j = 0; j < arr.length; j++) {
            // Во внутрь this будем перезаписывать элементы по номерам
            this[counter] = arr[j]; /* arr[j] - каждый отдельный элемент который мы нашли по селектору внутри копии, а this[counter] -
это общий объект куда мы записываем по порядку. Каунтер начинается с нуля , это значит что старые свойство с объекта this перезаписываем
и значение их будет тоже меняться  */

            counter++;
        }

        numberOfItems += arr.length;
    }

    this.length = numberOfItems;

    /* {
    0: node; // selector
    0: node; // selector
    0: node; // selector
    0: node;
    0: node;
   } 
     Вот как это работает, у нас есть 5 элементов, только у 3 из них есть нужным нам селектор, значит нам нужно взять эти 3,
а те 2 просто удалить*/

    const objLength = Object.keys(this).length; // получаем общее кство элементов в объекте
    for (; numberOfItems < objLength; numberOfItems++) {
        delete this[numberOfItems]; // оставшиеся хвостик как в примере с нодами будет удаляться
    } /* Мой цикл будет работать до тех пор пока numberOfItems будет меньше чем кство элементом которые лежали внутри this */
    
    return this;

};
/* Здесь БУДЕТ приходить объект this и внутри this нужно найти как в объекте все те элементы которые нам будут подходить по селектору
(по классу). И НАМ НУЖНО БУДЕТ С МЕТОДА find ВЕРНУТЬ ОБЪЕКТ С ОСТАВШИМЕСЯ ЭЛЕМЕНТАМИ С НУЖНЫМИ НАМ КЛАССОМ, а старые мы просто будем
удалять, одновременно перезаписав свойство length, потому что кство тоже изменится  */