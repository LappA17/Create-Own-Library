import $ from '../core';

/* Исправляем в конце урока баг, что при открытие модельного окна вся страничка темнеет. Это потому что у нас каждый раз создается
еще одно модельное окно, и так как все мод окна содержат один и тот же айди, то все они открываются и накрываются один на одного */
$.prototype.modal = function(created) {
    for (let i = 0; i < this.length; i++) {
        const target = this[i].getAttribute('data-target');
        $(this[i]).click((e) => {
            e.preventDefault();
            $(target).fadeIn(500);
            document.body.style.overflow = 'hidden';
        });

/* Мы вырезали все что ниже и поместили в цикл
   Теперь мы будем использовать closeElements уже в том мод окне которое сейчас будет использоваться
`${target}[data-close]` - мы поместили переменную таргет - а это мод окно которое нас интересовало */
        const closeElements = document.querySelectorAll(`${target} [data-close]`);
        closeElements.forEach(elem => {
            $(elem).click(() => {

/* Здесь вместо того что бы закрывать все мод окна, просто прописываем таргет. Вместо таргет у нас подставиться уникальный
индификатор вместо строки и соотвестенно мы закроем только то мод окно которое сейчас открыто */
                $(target).fadeOut(500);
                document.body.style.overflow = '';

/* Если вдруг параметр create был передан - это значит что наше мод окно было созданно при помощи скрипта, и если это так, то после того
как мы его закроем, то мы должны УДАЛИТЬ его со страницы, иначе будет баг с множеством мод окон */
                if (created) {
                    document.querySelector(target).remove();
                }
            });
        });
        // Тоже таргет вместо .модал
        $(target).click(e => {
            if (e.target.classList.contains('modal')) {
                $(target).fadeOut(500);
                document.body.style.overflow = '';
                if (created) {
                    document.querySelector(target).remove();
                }
            }
        });
    }
};

$('[data-toggle="modal"]').modal();

// Создадим метод который сможем вызывать на опредленных элементах, что бы появлялось мод окно привяазанное четко к этому триггеру
$.prototype.createModal = function({text, btns} = {}) { /* в text будет тайтел и бади , в бтнс будут кнопки и их настройки */
    for (let i = 0; i< this.length; i++) {
        let modal = document.createElement('div'); // Создаем оболочку, это тоже самое что <div class="modal" id="exampleModal">
        modal.classList.add('modal');
        modal.setAttribute('id', this[i].getAttribute('data-target').slice(1));/* устанавливаем атрибут айди и в него записываем значение дата
        таргер так как он вызывает мод окно. НАМ НУЖНО УБРАТЬ РЕШЕТКУ У data-target="#exampleModal2", ВЕДЬ МЫ УСТАНАВЛИВАЕМ АЙДИ 
        slice(1) - я получу всю строку без первого символа*/

        // Займемся созданием кнопок
        // btns = {count: num, settings: [[text, classNames=[], close, cb]]}
        const buttons = [];
        for (let j = 0;j < btns.count; j++){/* У нас будет свойство count и благодаря нему мы будем в будущем его передавать и говорить
СКОЛЬКО КНОПОК НАМ ПОНАДОБЯТЬСЯ ведь сейчас мы этого не знаем */
            
/* Нам btns будет вот таким btns = {count: num, settings: [[text, classNames = [] , close, cb]]} , те внтри батенс есть его число, и массив 
внутри массива в сеттингс. Сам массив будет иметь какой-то текст, подставляем ему класс и кнопку закрытия модельного окна и callback -
а это та фция которая будет выполняться после килка по этой кнопки.
Те это всё один массив [text, classNames = [] , close, cb] который равен одной кнопке, но если кнопок буде больше то просто через запятую
добавиться еще один массив со своими значениями. ПО ЭТОМУ МАССИВ ВНУТРИ МАССИВА [[text, classNames = [] , close, cb], [text, classNames = [] , close, cb]] */
            let btn = document.createElement('button');
            btn.classList.add('btn', ...btns.settings[j][1]);
/*  Мы хотим достучаться до classNames, при этом узнав какой номер массив с помощью btns.settings[j], переменная j знает какая у нас кнопка
перебирается.
    [1] - это classNames, так как он массив задаем ему значение ввиду массива  
    Рас уж мы буде задавать классы внутри массива, мы можем применить рест опператор, для того что бы развернуть этот массив на каждый
отдельный элемент. Те все что мы передадим в качестве строк в этот массив, здесь просто развернется и подставиться в classNames,
те те переменные которые мы создавали в scss, это значит можем подставлять много нужных нам css стилей*/

            // Назначаем текст внутрь кнопки
            btn.textContent = btns.settings[j][0]; // Теперь тот текст который мы передаем в настройках в text

            // close
            if (btns.settings[j][2]) { // потому что close у нас 3 по порядку в массиве. Если в if true, то устанавливаем атрибут закрытия
                btn.setAttribute('data-close', 'true');
            }
            // callback(если он существует и если коллбек вообще является функцией)
            if (btns.settings[j][3] && typeof(btns.settings[j][3]) === 'function') { /* function - не является типом данных,
но typeof может возвращать такое значение */
                btn.addEventListener('click', btns.settings[j][3]);
            }

            buttons.push(btn); // Теперь buttons это массив где внутря хранятся отдельные btn тоже в виде массива
        }/* Просто так в футер мы массив вставить НЕ СМОЖЕМ. Перебрать массив, превратив его в ноду тоже не получиться ведь 
теряется колл бек и фциональность, при трансформации ноды в строку коллбек исчезнит. По этому используем метод append */

        modal.innerHTML = `
        <div class="modal-dialog">
            <div class="modal-content">
                <button class="close" data-close>
                    <span>&times;</span>
                </button>
                <div class="modal-header">
                    <div class="modal-title">
                        ${text.title}
                    </div>
                </div>
                <div class="modal-body">
                    ${text.body}
                </div>
                <div class="modal-footer">
                    
                </div>
            </div>
        </div>
        `; /* Подставляем с помощью интерпаляции то значение текста, бади которые будут меняться */

        modal.querySelector(".modal-footer").append(...buttons);
/* Мы находим в том модельном окне что выше modal-footer куда мне нужно подставить нужные мне кнопки с помощью append + 
нужно использовать рест опператор что бы развернуть наш массив на каждый отдельный элемент который просто возьмуться и поместяться
в модал футер*/

        // Переменная модал существует только внутри джаваскрипта
        document.body.appendChild(modal);
        $(this[i]).modal(true);/* Те когда запуститься фций modal, в конце она так же подвяжет этот триггер 
        к этому новосозданному мод окну 
        Передаем true потому что таким образом мы скажем что это модельное окно было созданно ТЕХНИЧЕСКИ*/
        $(this[i].getAttribute('data-target')).fadeIn(500);/* Так мы получаем то мод окно, которые мы хотим действительно открыть */

        /* Добавляем id="trigger" что бы можно было быстро обращаться(в ссылку card добавили ту айди)
  + комментируем первое мод окно потому что при клике мы будем именно его вызывать */
    }
};